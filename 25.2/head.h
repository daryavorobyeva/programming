#ifndef HEAD_H_INCLUDED
#define HEAD_H_INCLUDED

typedef double element_t;

typedef struct node              // узел очереди, "связан" с соседними узлами
{
    struct node *next;
    struct node *prev;
    element_t data;
} node;

typedef struct deque             // очередь, хранит указатели на узлы - "голову" и "хвост"
{
    node *head;
    node *tail;
} deque;

deque* deque_alloc();                                  // выделяет память для структуры очереди; возвращает указатель на
                                                       // созданную структуру, если выделение успешно, иначе NULL.

void deque_free (deque *d);                            // освобождает память, выделенную для очереди и ее элементов;
                                                       // удаляет элементы, используя deque_pop_back(), пока очередь не станет пустой;
                                                       // затем освобождается память.

int deque_push_front (deque *d, element_t e);          // добавляет элемент в начало очереди; выделяет память для нового элемента;
                                                       // функция возвращает 0, если успешно, иначе -1.

int deque_push_back (deque *d, element_t e);           // аналогично, но добавление в конец очереди.

element_t deque_pop_front (deque *d);                  // удаляет элемент из начала очереди; сохраняет значение первого элемента,
                                                       // удаляет  и освобождает память; если очередь пуста, возвращает -1.

element_t deque_pop_back (deque *d);                   // аналогично, но удаление из конца.

deque* deque_clone (const deque *d);                   // создает копию очереди; выделяет память для новой очереди
                                                       // и копирует все элементы из старой очереди в новую;
                                                       // возвращает указатель на новую очередь, иначе NULL.

void print_deque(deque *d);                            // выводит значения элементов очереди; начинает с головы и переходит
                                                       // к следующему элементу, пока не достигнет конца.

element_t deque_get_front(deque *d);                   // возвращает значение первого элемента очереди.

#endif // HEAD_H_INCLUDED
